##########
# Includes
#########
include "update.bzz"
include "utils/vec2.bzz"
include "utils/takeoff_heights.bzz"
# include "formations/circling_experiment.bzz"
include "formations/Object_movement_test.bzz"
include "formations/forward_test.bzz"


#####
# Vehicule type:
# 0 -> outdoor flying vehicle
# 1 -> indoor flying vehicle
# 2 -> outdoor wheeled vehicle
# 3 -> indoor wheeled vehicle
V_TYPE = 3

# Global variables


# Executed once at init time.
function init() {	
	# start the swarm command listener
	nei_cmd_listen()

	# run the hierarchical movement init
	hierarchical_init()

    # Starting state: TURNEDOFF to wait for user input.
	BVMSTATE = "TURNEDOFF"
}

# Executed at each time step.
function step() {
	log("[",id,"] POS (",pose.position.x,",",pose.position.y,",",pose.position.z,")")
	# listen to Remote Controller
	rc_cmd_listen()

	#
	# State machine
	#
	if(BVMSTATE=="TURNEDOFF"){
		statef=turnedoff
	} 
	else if(BVMSTATE=="STOP"){	# ends on turnedoff
		statef=stop
	}
	else if(BVMSTATE=="LAUNCH"){ # ends on AUTO_LAUNCH_STATE
		statef=launch
	}
    # else if(BVMSTATE=="CIRCLING_EXPERIMENT"){
    #     statef=circling_experiment		
    # }
    else if(BVMSTATE=="FORMATION_MOVEMENT"){
        statef=hierarchical_step		
    }
    else if(BVMSTATE == "FORWARD_TEST"){
    	statef=forward_test
    }
	statef()

	#log("Current state: ", BVMSTATE)
}
 
# Executed once when the robot (or the simulator) is reset.
function reset() {
}
 
# Executed once at the end of experiment.
function destroy() {
}

# An extract of Core States 
# Core state function to launch the robot: takeoff and wait for others, or stop (land)
function launch() {
	BVMSTATE = "LAUNCH"
	neighbors.broadcast("cmd", 22)
	if(pose.position.z >= takeoff_heights[id]-takeoff_heights[id]/20.0 or V_TYPE == 3) {
		log("Auto state", AUTO_LAUNCH_STATE)
		BVMSTATE=AUTO_LAUNCH_STATE
	} else {
		log("Altitude: ", pose.position.z)
		uav_takeoff(takeoff_heights[id])
	}
	
}

# Core state function to stop and land.
function stop() {
  BVMSTATE = "STOP"
  if(pose.position.z <= 0.2) {
		BVMSTATE = "TURNEDOFF"
	} else{
		uav_land()
		neighbors.broadcast("cmd", 21)
	}
}

# Core state function when on the ground
function turnedoff() {
    BVMSTATE = "TURNEDOFF"
}

function rc_cmd_listen() {
	if(BVMSTATE=="TURNEDOFF") {
		if(flight.rc_cmd==22) {	#TAKEOFF\LAUNCH
			flight.rc_cmd=0
			BVMSTATE = "LAUNCH"
			neighbors.broadcast("cmd", 22)
		} 
	} else if(BVMSTATE != "STOP") {
		if(flight.rc_cmd==21) {
			flight.rc_cmd=0
			BVMSTATE = "STOP"
			neighbors.broadcast("cmd", 21)
		} 
	}
}

# listens to neighbors broadcasting commands
function nei_cmd_listen() {
    neighbors.listen("cmd",
		function(vid, value, rid) {
			print("Got (", vid, ",", value, ") #", rid, "(", BVMSTATE, ")")
			if(BVMSTATE=="TURNEDOFF") {
				if(value==22) {
					BVMSTATE = "LAUNCH"
				}
			} else if(BVMSTATE != "STOP") {
				if(value==21 and BVMSTATE != "STOP") {
					BVMSTATE = "STOP"
					neighbors.broadcast("cmd", 21)
				}
			}
    })
}

# goto wrapper for argos based scripts
function goto(x, y) {
	var height = takeoff_heights[id]
	var g_vec = math.vec2.new(x,y)
	var norm_fact= 1.0
	if(math.vec2.length(g_vec) > 0.0){
		norm_fact = 1.0/math.vec2.length(g_vec)
	}
	var norm_goto = math.vec2.scale(g_vec, norm_fact)
	norm_goto = math.vec2.scale(norm_goto, 0.3)
	goto_abs(norm_goto.x, norm_goto.y, height, 0.0)
}
