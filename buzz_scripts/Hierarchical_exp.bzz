##########
# Includes
#########
include "update.bzz"
include "utils/vec2.bzz"
include "utils/takeoff_heights.bzz"
# include "formations/circling_experiment.bzz"
include "formations/Object_movement_test.bzz"
include "formations/forward_test.bzz"


#####
# Vehicule type:
# 0 -> outdoor flying vehicle
# 1 -> indoor flying vehicle
# 2 -> outdoor wheeled vehicle
# 3 -> indoor wheeled vehicle
V_TYPE = 3

# ROBOT TYPES BASED ON SPECILIZATION
# SHEEP = 0
# DOG = 1

# Explorer robot (key-> ID, value -> Priority)
EXPLORER_IDs = {.1=1, .9=2}
EXPLORER = 0


# Global variables
init_motion = 0 # Varible to determine if initialization is done.
radiation_source_located = 0
homing_complete = 0

# Constants
GOTODIST_TOL = 0.1
GOTO_MAXVEL = 2 #m/s 

# Executed once at init time.
function init() {	
	# start the swarm command listener
	nei_cmd_listen()

	# run the hierarchical movement init
	hierarchical_init()

	# Determine your role.
	if(not (isnil(EXPLORER_IDs[id]))){
		EXPLORER = 1
	}
    # Starting state: TURNEDOFF to wait for user input.
	BVMSTATE = "TURNEDOFF"
}

# Executed at each time step.
function step() {
	log("[",id,"] POS (",pose.position.x,",",pose.position.y,",",pose.position.z,") yaw: ", pose.orientation.yaw)
	# listen to Remote Controller
	rc_cmd_listen()

	#
	# Top level State machine for Radiation cleanup experiment.
	# States: 
	# 1. TURNEDOFF -> the robot does nothing, it ideals
	# 2. STOP -> A state to transition to turnedoff.
	# 3. LAUNCH -> Entry state that performs initlization for the robot to transition to the subsequent states.
	# 4. EXPLORE -> Explores the environment until a target is detected. 
	# 5. RETURN_TO_BASE -> TARGET found return to base to dump the map and pickup followers.
	# 6. HIRACHIAL_BEHAVIORS -> Uses hirarchial control to perfrom a mission. 
	#
	if(BVMSTATE=="TURNEDOFF"){
		statef=turnedoff
	} 
	else if(BVMSTATE=="STOP"){	# ends on turnedoff
		statef=stop
	}
	else if(BVMSTATE=="LAUNCH"){ # ends on AUTO_LAUNCH_STATE
		statef=launch
	}
	else if(BVMSTATE=="EXPLORE"){
		statef=explore
	}
	else if(BVMSTATE=="RETURN_TO_BASE"){
		statef=return_to_base
	}
    else if(BVMSTATE=="HIRACHIAL_BEHAVIORS"){
        statef=hierarchical_step		
    }
    else if(BVMSTATE == "FORWARD_TEST"){
    	statef=forward_test
    }
    # else if(BVMSTATE=="CIRCLING_EXPERIMENT"){
    #     statef=circling_experiment		
    # }

	statef()

	#log("Current state: ", BVMSTATE)
}
 
# Executed once when the robot (or the simulator) is reset.
function reset() {
}
 
# Executed once at the end of experiment.
function destroy() {
}

# Implementation of Core States 
# Core state function to launch the robot: takeoff and wait for others, or stop (land)
function launch() {
	BVMSTATE = "LAUNCH"
	neighbors.broadcast("cmd", 22)
	if(pose.position.z >= takeoff_heights[id]-takeoff_heights[id]/20.0 or V_TYPE == 3) {
		log("Auto state", AUTO_LAUNCH_STATE)
		BVMSTATE=AUTO_LAUNCH_STATE
	} else {
		log("Altitude: ", pose.position.z)
		uav_takeoff(takeoff_heights[id])
	}
	
}

# Core state function to stop and land.
function stop() {
  BVMSTATE = "STOP"
  if(pose.position.z <= 0.5) {
		BVMSTATE = "TURNEDOFF"
		goto(0.0,0.0)
	} else{
		uav_land()
		neighbors.broadcast("cmd", 21)
	}
}

# Core state function when on the ground
function turnedoff() {
    BVMSTATE = "TURNEDOFF"
}

# Core state to explore and map the environment. 
function explore(){
	BVMSTATE ="EXPLORE"
	if(ROLE == DOG){
		# Coordinate the exploration with other robots. 
		if(id == EXPLORER){
			# Perform the initialization motion to determine the exploration direction. 
			if(init_motion == 0){
				# forward motion of 2 meters 
				var vec_to_target = math.vec2.new(2,0)
				
				if(not (goto_point(vec_to_target)) ){
					# init motion complete
					init_motion = 1
				}
			}
			else{
				# Perform local planning to maximize the environmental information and coverage.
				if( isnil(CUR_PATH)){
					if(call_local_planner()){
						CUR_PATH = get_local_planner_path()
					}
				}
				else{
					var cur_wp = math.vec2.new(CUR_PATH[CUR_WP_IDX].x, CUR_PATH[CUR_WP_IDX].y)
					if(not (goto_point(cur_wp))){
						# WP reached
						if(CUR_WP_IDX < size(CUR_PATH)){
							CUR_WP_IDX = CUR_WP_IDX + 1
						}
						else{
							CUR_PATH = nil
							goto(0.0,0.0)
						}
					}
				}
				# Scan for radiation.
				if(flight.rc_cmd == 911){
					flight.rc_cmd = 0
					radiation_source_located = 1
				}
				if(radiation_source_located == 1){
					# return to base or Home
					# Tell exploration planner to home.
					# TODO: STILL PATH needs to be populated in the BVM with the navigation tube.
					do_homing()
					if(homing_complete == 1){
						# 
					}
				}
			}
		}
	}
	else{
		# just ideal, if you are not capable of exploring.

	}
}


# function to handle rc commands.
function rc_cmd_listen() {
	if(BVMSTATE=="TURNEDOFF") {
		if(flight.rc_cmd==22) {	#TAKEOFF\LAUNCH
			flight.rc_cmd=0
			BVMSTATE = "LAUNCH"
			neighbors.broadcast("cmd", 22)
		} 
	} else if(BVMSTATE != "STOP") {
		if(flight.rc_cmd==21) {
			flight.rc_cmd=0
			BVMSTATE = "STOP"
			neighbors.broadcast("cmd", 21)
		} 
	} else if(BVMSTATE == "EXPLORE"){
		if(flight.rc_cmd == 888){
			BVMSTATE = "HIRACHIAL_BEHAVIORS"
			neighbors.broadcast("cmd",888)
		}
	}
}

# listens to neighbors broadcasting commands
function nei_cmd_listen() {
    neighbors.listen("cmd",
		function(vid, value, rid) {
			print("Got (", vid, ",", value, ") #", rid, "(", BVMSTATE, ")")
			if(BVMSTATE=="TURNEDOFF") {
				if(value==22) {
					BVMSTATE = "LAUNCH"
				}
			} else if(BVMSTATE != "STOP") {
				if(value==21 and BVMSTATE != "STOP") {
					BVMSTATE = "STOP"
					neighbors.broadcast("cmd", 21)
				}
			} else if(BVMSTATE == "EXPLORE"){
				if(value = 999 and BVMSTATE != "RETURN_TO_BASE"){
					BVMSTATE = "RETURN_TO_BASE"
				}
			}
    })
}

# goto wrapper for argos based scripts
function goto(x, y) {
	var height = takeoff_heights[id]
	var g_vec = math.vec2.new(x,y)
	var norm_fact= 10.0
	var norm_goto = math.vec2.scale(g_vec, norm_fact)
	if(math.vec2.length(norm_goto) < 0.737463127){
	   norm_goto = math.vec2.scale(norm_goto, 0)
	}
	# Convert cm to m
	norm_goto.x = 1.0/100.0 * norm_goto.x
	norm_goto.y = 1.0/100.0 * norm_goto.y
	goto_abs(norm_goto.x, norm_goto.y, height, 0.0)
}

function goto_point(pt){
	var local_vec = math.vec2.sub(vec_to_target,pose.position)
	local_vec = math.vec2.rotate(local_vec, -pose.orientation.yaw)
	if(math.vec2.length(local_vec) < GOTODIST_TOL){
		# cvt to cms
		local_vec = math.vec2.scale(local_vec,100)
		# Limit speed
		local_vec = math.vec2.newp(math.min(GOTO_MAXVEL,math.vec2.length(local_vec)),math.vec2.angle(local_vec))
		goto(local_vec.x,local_vec.y)
		return 1
	}
	else{
		return 0
	}
}