#####
# Simulation or real robot
# 
SIM = 1

#####
# RC COMMANDS accepted by the robots
#####
No_cmd = 0
Turnoff_cmd = 21
Explore_cmd = 1
Home_cmd = 2
Wp_cmd = 3
Find_object_cmd = 4
Sit_cmd = 5
Stand_cmd = 6
Dance_cmd = 7
all_robots_explore_cmd = 8
all_robots_home_cmd = 9



##########
# Includes
#########
#include "update.bzz"
# include "vec2.bzz"

include "utils/vec2.bzz"

#####
# Vehicule type:
Rovers=0
Legged = 1
# The robot running this script type.
V_TYPE = 1

# Legged robot leg states.
SITTING = 0
STANDING = 1


# Constants
GOTODIST_TOL = 0.6
GOTO_MAXVEL = 0.5 #m/s 
EXPLORATION_YEILD = 250 #cms
PLANNER_TIME_OUT = 400 # 40 sec
STUCK_TIME_OUT = 400 # 40 sec 
RETRY_TIME = 200 # 20 sec for spot commands
YAW_OFFSET=3.14
SAFETY_DISTANCE = 35
HARMON_A0 = 0.0
HARMON_K = 1.0/50.0
STUCK_RECOVERY_TIME=5
TARGET_DETECTION_RANGE = 500 #cms Detect a target within this range
COOL_DOWN_TIME = 250 # explorer cool down for 5 sec before any action.
MIN_WORKERS_COUNT = 1
REQUIRED_GUIDES = 2
MAX_EXPLORATION_QUOTA_WORKER=100 # Distance the worker robots can explore in m.
EVOLVED_EXPLORATION_QUOTA_WORKER=MAX_EXPLORATION_QUOTA_WORKER
MAX_RETRY_CMD = 3 # Retry for spot commands.


map_path="/home/vivek/Vivek/Projects/Hierarchical_Swarm/KheperaIV"
map_name="BUZZ_SCRIPT_NAME"
# BEHAVIOR_FILE_NAME = string.concat(FILE_PATH, string.tostring(id), "-Behavior_bzz_log.csv")
# csv_file =""
TIME_TO_DECLARE_GOAL_REACHED = 10
# Explorer robot (key-> ID, value -> Priority, lower higher priority)
EXPLORER_IDs = {.0=1, .1=2, .3=3}
INIT_MOTIONS ={.0={.x=1.5, .y=0.0}, .1={.x=1.5, .y=0.0},.3={.x=1.5, .y=0.0},.1200={.x=1.5,.y=0.0} }



# Global variables
BVMSTATE = "LAUNCH"
statef = turned_off
init_motion = 0 # Varible to determine if initialization is done.
homing_complete = 0
CUR_PATH ={}
OLD_PATH ={}
CUR_WP_IDX =0
planner_time = 0
global_planner_called=0
local_planner_called = 0 
retry = 0 # for spot 
hierarchial_path_to_source = {}
hierarchial_navigational_tube = {}
Move_base_tracking_goal = 0
Goal_reached_declare_timer = 0
robot = {.rc_cmd=0}
time_step = 0
waypoint_set_time = 0
planner_stuck_trigger = 0 
old_pose={}
used_exploration_quota=0
OBJECTS = {}
spot ={.state={.standing=0,.sitting=0,.moving=0}}
retry_timer = 0
legged_robot_state = SITTING
AUTO_LAUNCH_STATE = "TURNEDOFF"


# WP following state
CUR_WP_FROM_VIZ = {}
cur_wp = {}



# Executed once at init time.
function init() {	
	# Open csv file to record data
    # csv_file = io.fopen(BEHAVIOR_FILE_NAME, "w")
	# start the swarm command listener
	nei_cmd_listen()


	# Stigmery for sharing path.
	path_stig = stigmergy.create(104)

  	# Starting state: TURNEDOFF to wait for user input.
	BVMSTATE = "TURNEDOFF"

	log("my id ",id, "BVM STATE ", BVMSTATE)

	# Init uwb tag seeking variables.
	pose_at_uwb_update = math.vec2.new(0.0,0.0)
	uwb_dist_to_source_map = {.0=0,.1=0,.2=0,.3=0,.4=0,.5=0,.6=0,.7=0}

	# set moving exploration quota
	EVOLVED_EXPLORATION_QUOTA_WORKER=MAX_EXPLORATION_QUOTA_WORKER
}

# Executed at each time step.
function step() {
	# log("[",id,"] POS (",pose.position.x,",",pose.position.y,",",pose.position.z,") yaw: ", pose.orientation.yaw, " WP ",CUR_WP_IDX)
	# log("BVM state: ", BVMSTATE, " EXPLORE_STATE ", EXPLORE_STATE)
	# listen to Remote Controller
	rc_cmd_listen()




	#
	# Top level State machine for Radiation cleanup experiment.
	# States: 
	# 1. TURNEDOFF -> the robot does nothing, it ideals
	# 2. STOP -> A state to transition to turnedoff.
	# 3. LAUNCH -> Entry state that performs initlization for the robot to transition to the subsequent states.
	# 4. EXPLORE -> Explores the environment until a set quota is fullfiled. 
	# 5. HOME -> Return home after the quota fullfilment.
	# 6. EXPLORE_FIND_OBJECT -> Explore looking for an object.
	# 7. HOME_AFTER_OBJECT_FOUND -> Home after finding the object of interest.
	# 8. WAYPOINT_GOTO -> goto an assigned waypoint.
	# 9. SIT -> only legged robots can do or transition to, performs a sit behavior.
	# 10. STAND -> only legged can do or transition to, perform a sit behavior.
	# 11. DANCE -> TODO: Has to be implemented. 
	# 12. YEILD -> Yeild for Humans or higher priority robot.
	# 13. UWB_ANCHOR_FOLLOW -> Follow the gradiend to of an anchor. TODO: Has to be implemented.
	#
	if(BVMSTATE=="TURNEDOFF"){
		statef=turnedoff
	} 
	else if(BVMSTATE=="STOP"){	# ends on turnedoff
		statef=stop
	}
	else if(BVMSTATE=="LAUNCH"){ # ends on AUTO_LAUNCH_STATE
		statef=launch
	}
	else if(BVMSTATE=="EXPLORE"){
		statef=explore
	}
	else if(BVMSTATE=="HOME"){
		statef=home
	}
	else if(BVMSTATE == "EXPLORE_FIND_OBJECT"){
		statef=explore_find_object
	}
	else if(BVMSTATE == "HOME_AFTER_OBJECT_FOUND"){
		statef=home_after_object_found
	}
	else if(BVMSTATE == "WAYPOINT_GOTO"){
		statef=waypoint_goto
	}
	else if(BVMSTATE == "SIT"){
		statef=sit
	}
	else if(BVMSTATE == "STAND"){
		statef=stand
	}
	else if(BVMSTATE == "DANCE"){
		statef=dance
	}
	else if(BVMSTATE == "YEILD"){
		statef = yeild
	}
	else if(BVMSTATE == "UWB_ANCHOR_FOLLOW"){
		statef=uwb_anchor_follow
	}

	log("Cur state: ",BVMSTATE)

	statef()

	time_step = time_step + 1
}
 
# Executed once when the robot (or the simulator) is reset.
function reset() {
}
 
# Executed once at the end of experiment.
function destroy() {
	# io.fclose(csv_file)
}

# Core state function when on the ground
function turnedoff() {
    BVMSTATE = "TURNEDOFF"
}

# Core state function to stop and land.
function stop() {
	BVMSTATE = "STOP"
	# check for something before going to turnedoff.
	# TODO: Implement sitting and standing.
	BVMSTATE = "TURNEDOFF"
	goto(0.0,0.0)
	# tell everyone that you are going to turned off
	neighbors.broadcast("cmd", 21)
}

# Implementation of Core States 
# Core state function to launch the robot: takeoff and wait for others, or stop (land)
function launch() {
	BVMSTATE = "LAUNCH"
	# neighbors.broadcast("cmd", 22)
	# if(V_TYPE == 0) {
	log("[",id,"] Auto state: ", AUTO_LAUNCH_STATE)
	BVMSTATE=AUTO_LAUNCH_STATE
	# }
	
}

function waypoint_goto(){
	BVMSTATE = "WAYPOINT_GOTO"
	if(size(CUR_WP_FROM_VIZ) > 0){
		if(waypoint_set_time == 0){
			waypoint_set_time = time_step
		}
		# forward motion of 2 meters 
		var vec_to_target = CUR_WP_FROM_VIZ
		var last_wp = 0				
		if(goto_point_naive(vec_to_target, last_wp) == 0){
			# init motion complete
			goto(0.0,0.0)
			log("[",id,"] WP REACHED ")
			BVMSTATE = "TURNEDOFF"
			CUR_WP_FROM_VIZ ={}
			waypoint_set_time = 0
		}
	}
}


function explore(){
	BVMSTATE ="EXPLORE"
	exploration()
}

function home(){
	BVMSTATE = "HOME"
	homing()
}

function explore_find_object(){
	if(size(OBJECTS) > 0){
		OBJECTS = {}
		BVMSTATE = "HOME"
	}
	else{
		BVMSTATE = "EXPLORE_FIND_OBJECT"
		exploration()
	}
}

function sit(){
	if(V_TYPE == Legged){
		BVMSTATE = "SIT"
		if(retry < MAX_RETRY_CMD){
			if(retry_timer == 0 or time_step - retry_timer > RETRY_TIME){
				call_sit_service()
				log("called sit service")
				retry_timer = time_step
				retry = retry + 1
			}
			else{
				if(spot.state.sitting == 1){
					BVMSTATE = "TURNEDOFF"
					retry_timer = 0
					retry = 0
				}
			}
		}
	}
	else{
		log("Wheeled robot can't sit.")
		BVMSTATE = "TURNEDOFF"
	}
	goto(0.0,0.0)
}

function stand(){
	if(V_TYPE == Legged){
		BVMSTATE = "STAND"
		if(retry < MAX_RETRY_CMD){
			if(retry_timer == 0 or time_step - retry_timer > RETRY_TIME){
				call_stand_service()
				log("called sit service")
				retry_timer = time_step
				retry = retry + 1
			}
			else{
				if(spot.state.standing == 1){
					BVMSTATE = "TURNEDOFF"
					retry_timer = 0
					retry = 0
				}
			}
		}
	}
	else{
		log("Wheeled robot can't stand.")
		BVMSTATE = "TURNEDOFF"
	}
	goto(0.0,0.0)
}

function dance(){
	BVMSTATE = "DANCE"

}

function yeild(){
	BVMSTATE = "YEILD"
}
# function call_sit_service(){

# 	log(" Dummy sit service called !!!")
# 	if(retry == 1) legged_robot_state = SITTING
# }


# function call_stand_service(){

# 	log(" Dummy stand service called !!!")
# 	if(retry == 1) legged_robot_state = STANDING
# }

# Core state to explore and map the environment. 
function exploration(){
	# Keep broadcasting msg if you or nei found the radiation source.
	if(global_planner_called == 1){
		neighbors.broadcast("cmd", 911)
	}

	# Coordinate the exploration with other robots. 
	# if(high_priority_robot_in_field()){
	# 	EXPLORE_STATE = EXPLORE_YEILDING
	# 	goto(0,0)
	# 	return
	# }
	
	# Perform the initialization motion to determine the exploration direction. 
	if(init_motion == 0){
		# forward motion of 2 meters 
		var vec_to_target = INIT_MOTIONS[id]
		var last_wp = 0
		waypoint_set_time = time_step				
		if(goto_point_naive(vec_to_target, last_wp) == 0){
			# init motion complete
			goto(0.0,0.0)
			var clear_all_exsisting paths = get_local_planner_path()
			init_motion = 1
			# set_planner_home_location(0.0,0.0,0.0,pose.orientation.yaw)
			log("[",id,"] INIT MOTION DONE")
		}
		log("Doing init")
	}
	else{
		# Perform local planning to maximize the environmental information and coverage.
		if(local_planner_called == 0 ){
			var discard_old_catched_path = get_local_planner_path()
			call_local_planner()
			local_planner_called = 1
			planner_time = time_step
			planner_control_interface_inuse = 1
			planner_stuck_trigger = 0
		}
		else{
			var path_empty_check = 1
			if(not isnil(CUR_PATH)){
				if(size(CUR_PATH) > 0){
					path_empty_check = 0
				}
			}

			if(time_step - planner_time > PLANNER_TIME_OUT and path_empty_check == 1  ){
				# If the planner is stuck, possibly got close to an obstacle. 
				# Retract to the previous point and plan.
				if(size(OLD_PATH) > 0){
					planner_stuck_trigger = 1
					var idx = size(OLD_PATH) - 3
					var f_idx = 0
					CUR_PATH = {}
					log("ERROR: Stuck while planning, going back to the previous point to plan.")
					while(idx >= 0){
						CUR_PATH[f_idx] = {.x=OLD_PATH[idx].x, .y=OLD_PATH[idx].y}
						idx = idx - 1
						f_idx = f_idx + 1 
					}
					# log("[",id,"] cur path", size(CUR_PATH)," old ", size(OLD_PATH))

					planner_time = time_step
					OLD_PATH = {}
					CUR_WP_IDX = 0
					waypoint_set_time = time_step
				}
				else{
					log("ERROR: Planner got stuck, can't go back to previous point. I am in a deadlock, free me please.")
				}		
			}
			# Following a path, complete the path.
			# Check if you got a path from planner.
			if(path_empty_check == 1){
				CUR_PATH = get_local_planner_path()
				waypoint_set_time = time_step
				CUR_WP_IDX=0
				goto(0.0,0.0)
			}
			else{
				# I got the path from the planner, Pursue it.
				planner_control_interface_inuse = 0
				var cur_wp = math.vec2.new(CUR_PATH[CUR_WP_IDX].x, CUR_PATH[CUR_WP_IDX].y)
				var last_wp = 0

				if(not (goto_point_naive(cur_wp, last_wp))){
					# WP reached going to next.
					if(CUR_WP_IDX < size(CUR_PATH)-1){
						CUR_WP_IDX = CUR_WP_IDX + 1
						waypoint_set_time = time_step
					}
					else{
						if( planner_stuck_trigger == 0 ){
							OLD_PATH = copy_table_vec2(CUR_PATH)
						}
						CUR_PATH = nil
						var clearing_old_paths = get_local_planner_path()
						CUR_WP_IDX=0
						local_planner_called = 0
						goto(0.0,0.0)
					}
				}
			}
		}
	}	
}

function homing(){
	if(isnil(CUR_PATH)){
		CUR_PATH = get_global_planner_path()
		if(size(CUR_PATH) > 0){ 
			interpolated_path = get_intrapolated_path()
			log(" global path size ", size(CUR_PATH)," size of interpolated ", size(interpolated_path))
			CUR_WP_IDX=0
			waypoint_set_time = time_step
			goto(0.0,0.0)
		}
		
	}
	else if(size(CUR_PATH) <= 0){
		CUR_PATH = get_global_planner_path()
		if(size(CUR_PATH) > 0){
			reverse_table(CUR_PATH)
			interpolated_path = get_intrapolated_path()
			log(" global path size ", size(CUR_PATH)," size of interpolated ", size(interpolated_path))
			CUR_WP_IDX=0
			waypoint_set_time = time_step
			# save_map(map_path,map_name)  
			# if(SIMULATION){
			# 	# Stop planner
			# 	stop_exploration_planner()
			# }

		}
		# return to base or Home
		# Tell exploration planner to home using the global graph.
		if( (global_planner_called == 0) and (planner_control_interface_inuse == 0)){
			# Someother robot found the source, simply home.
			log("Calling global planner")
			call_global_planner() 
			global_planner_called = 1
		}
		else{
			if(planner_control_interface_inuse == 1){
				log("Local planner in called state")
				if(isnil(CUR_PATH)){
					var tmp_local_path = get_local_planner_path()
					if(size(tmp_local_path) > 0){
						planner_control_interface_inuse = 0
					}
				}
				else{
					CUR_PATH = nil
					var clearing_old_paths = get_local_planner_path()
					if(size(clearing_old_paths) > 0){
						CUR_WP_IDX=0
						planner_control_interface_inuse = 0 
					}
				}
			}
			# planner is working please wait.
			goto(0.0,0.0)
		}
	}
	else{
		var cur_wp = math.vec2.new(CUR_PATH[CUR_WP_IDX].x, CUR_PATH[CUR_WP_IDX].y)
		var last_wp = 0
		if(not (goto_point_naive(cur_wp, last_wp))){
			# WP reached
			if(CUR_WP_IDX < size(CUR_PATH)-1){
				CUR_WP_IDX = CUR_WP_IDX + 1
				waypoint_set_time = time_step
			}
			else if(CUR_WP_IDX >= size(CUR_PATH)-1){
				# Home reached, TODO: trigger hierarchial behaviror.
				log("HOME REACHED")
				BVMSTATE = "TURNEDOFF"
				goto(0.0,0.0)
			}
		}
	}
	
}

function yeild(){
	BVMSTATE="YEILD"
	if( not high_priority_robot_in_field()){
		BVMSTATE = OLD_YEILDING_STATE
	}
	log("Robot Yeilding to a nearby robot or human.")
	
}

# function to handle rc commands.
function rc_cmd_listen() {
	if(flight.rc_cmd != 0){
		log("New rc in bzz script ", flight.rc_cmd )
		robot ={.rc_cmd=flight.rc_cmd}
	}
	if(robot.rc_cmd == Turnoff_cmd){
		# reset the command after you read it.
		robot.rc_cmd=No_cmd
		# Clear all state info. 
		clear_all_state()
		clear_local_planner_state()
		BVMSTATE = "STOP"
	}
	else if(robot.rc_cmd == Explore_cmd){
		clear_all_state()
		BVMSTATE = "EXPLORE"
	}
	else if(robot.rc_cmd == Home_cmd){
		clear_all_state()
		BVMSTATE = "HOME"
	}
	else if(robot.rc_cmd == Wp_cmd){
		clear_all_state()
		clear_local_planner_state()
		BVMSTATE = "WAYPOINT_GOTO"
	}
	else if(robot.rc_cmd == Find_object_cmd){
		clear_all_state()
		BVMSTATE = "EXPLORE_FIND_OBJECT"
	}
	else if(robot.rc_cmd == Sit_cmd){
		clear_all_state()
		clear_local_planner_state()
		BVMSTATE = "SIT"
	}
	else if(robot.rc_cmd == Stand_cmd){
		clear_all_state()
		clear_local_planner_state()
		BVMSTATE = "STAND"
	}
	else if(robot.rc_cmd == Dance_cmd){
		clear_all_state()
		clear_local_planner_state()
		BVMSTATE = "DANCE"
	}
	else if(robot.rc_cmd == all_robots_explore_cmd){
		clear_all_state()
		BVMSTATE = "EXPLORE"
		neighbors.broadcast("cmd", Explore_cmd)
	}
	else if(robot.rc_cmd == all_robots_home_cmd){
		clear_all_state()
		BVMSTATE = "HOME"
		neighbors.broadcast("cmd", Home_cmd)
	}

	# check for new waypoints. If waypoint received, it goes into waypoint state overides current state.
	if(size(cur_wp) > 0){
		BVMSTATE = "WAYPOINT_GOTO"
		CUR_WP_FROM_VIZ = math.vec2.new(cur_wp.position.x,cur_wp.position.y)
		log("New wp received ", cur_wp.position.x, " , ",cur_wp.position.y)
		cur_wp = {}
	}

	robot.rc_cmd=No_cmd
	flight.rc_cmd=No_cmd
}

function clear_all_state(){
	# Local planner states clear.
	CUR_PATH = nil
	var clearing_old_paths = get_local_planner_path()
	CUR_WP_IDX=0
	local_planner_called = 0
	# Global planner states clear.
	global_planner_called = 0
	waypoint_set_time = 0
	# Spot retry cmds
	retry_timer = 0
	retry = 0
}

function clear_local_planner_state(){
	planner_control_interface_inuse = 0
}
# listens to neighbors broadcasting commands
function nei_cmd_listen() {
    neighbors.listen("cmd",
		function(vid, value, rid) {
			# print("Got (", vid, ",", value, ") #", rid, "(", BVMSTATE, ")")
			if(BVMSTATE=="TURNEDOFF") {
				if(value==22) {
					BVMSTATE = "LAUNCH"
				}
			} 
			else if(BVMSTATE != "STOP") {
				if(value==21 and BVMSTATE != "STOP") {
					BVMSTATE = "STOP"
					neighbors.broadcast("cmd", 21)
				}
			} 

			if(BVMSTATE == "EXPLORE"){
				if(value == 999 and BVMSTATE != "RETURN_TO_BASE"){
					BVMSTATE = "RETURN_TO_BASE"
				}
				if(value == 911 and EXPLORE_STATE != EXPLORE_RETUNING and rid > TARGET_ID){
                                        EXPLORE_STATE = EXPLORE_RETUNING
                                        BVMSTATE ="EXPLORE"
                                        CUR_PATH = nil
										CUR_WP_IDX = 0
										Move_base_tracking_goal = 0
                                        log(" Another Guide FOUND RADIATION !!!")
                }
			}
			# Bug algorithm neighbour trigger.
			if(value == 911){
				if(rid < TARGET_ID){ # It is another bug, so get to it if it is close enough.
					var nei_pos = neighbors.get(rid)
					
					Bugs_found_target[rid]=1
					if(nei_pos.distance < 200){
						nei_radiation = 1	
						nei_radiation_id = rid
						# log(" NEI FOUND RADIATION !!!")
					}
				}
				else if(rid > TARGET_ID){
					inbound_travel = 1
					broadcast_inbound = 1
				}
			}
			else if(value == 55 and id < TARGET_ID){
				inbound_travel = 1
				broadcast_inbound = 1
			}

    })
}

# TODO have to implement map save hook 
function save_map(map_path, map_name){
	log("TODO: save map called: Implement save map")
}


# simple goto wrapper on real robot.
function goto(x_g,y_g){
	goto_abs(x_g, y_g, 0.0, 0.0)
}


# Function to use ROS move base node (ROS navigational stack) along with ROSBuzz 
# This function takes goal in the /map frame. Using any other frame will create unexpexted behavior. 
# This function assumes get_local_trajectory_goal returns the origin when the goal is reached.
function goto_point(goal, last_wp){
	var goal_status = get_goal_status()
	#log("GOAL STATUS ", goal_status)
	if(goal_status){
		Goal_reached_declare_timer = Goal_reached_declare_timer + 1
		goto_abs(0.0, 0.0, takeoff_heights[id], 0.0)				
	}
	else{
		Goal_reached_declare_timer = 0
		goto_abs(0.0, 0.0, takeoff_heights[id], 0.0)				
	}
	if(Goal_reached_declare_timer > TIME_TO_DECLARE_GOAL_REACHED and Move_base_tracking_goal){
		goto_abs(0.0, 0.0, takeoff_heights[id], 0.0)				
		Move_base_tracking_goal = 0
		return 0
	}
	if(not Move_base_tracking_goal){
		Move_base_tracking_goal = 1
		set_navigation_goal(goal.x, goal.y)
		goto_abs(0.0, 0.0, takeoff_heights[id], 0.0)				
	}
	var local_goal_vec = get_local_trajectory_goal() # goal from the movebase planner.
  #log("Goal received ", local_goal_vec.x," , ", local_goal_vec.y)
		
  if(math.vec2.length(local_goal_vec) > 0){
	  var home_offset = math.vec2.new(pose.position.x_offset, pose.position.y_offset)
	  var NedPos = math.vec2.sub(pose.position,home_offset)
	  var local_vec = math.vec2.sub(local_goal_vec,NedPos)
	  local_vec_len = math.vec2.length(local_vec)
	  local_vec = math.vec2.rotate(local_vec, -1*pose.orientation.yaw)
    #log("local vec len ", local_vec_len, " vec ", local_goal_vec.x, ", ",local_goal_vec.y, " angle to goal ", math.abs( math.vec2.angle(local_vec)))

		if(math.abs( math.vec2.angle(local_vec)) > 2.0 ){ # Goal is directly behind the robot, rotate.
			goto_abs(-1.0, 0.0, takeoff_heights[id], 0.0)				
		}
		else{
	 		# scale to desired vel
			#local_vec = math.vec2.scale(local_vec,1)
			# Limit speed
			# local_vec = math.vec2.newp(math.vec2.length(local_vec)*10,math.vec2.angle(local_vec)) # Original for exploration
			local_vec = math.vec2.newp(math.vec2.length(local_vec)*5,math.vec2.angle(local_vec)) # altered for tag following
			goto_abs(local_vec.x, local_vec.y, takeoff_heights[id], 0.0)
		}
  }

	return 1	
}

# Function to use ROS move base node (ROS navigational stack) along with ROSBuzz and obtain a goto vec
# This function takes goal in the /map frame. Using any other frame will create unexpexted behavior. 
function movebase_point(goal){
	var goal_status = get_goal_status()
	var movebase_goto = math.vec2.new(0.0,0.0)
	#log("GOAL STATUS ", goal_status)
	if(goal_status){
		Goal_reached_declare_timer = Goal_reached_declare_timer + 1				
	}
	else{
		Goal_reached_declare_timer = 0
	}
	if(Goal_reached_declare_timer > TIME_TO_DECLARE_GOAL_REACHED and Move_base_tracking_goal){				
		Move_base_tracking_goal = 0
		return movebase_goto
	}
	if(not Move_base_tracking_goal){
		Move_base_tracking_goal = 1
		set_navigation_goal(goal.x, goal.y)				
	}
	var local_goal_vec = get_local_trajectory_goal() # goal from the movebase planner.
  #log("Goal received ", local_goal_vec.x," , ", local_goal_vec.y)
		
  if(math.vec2.length(local_goal_vec) > 0){
	  var home_offset = math.vec2.new(pose.position.x_offset, pose.position.y_offset)
	  var NedPos = math.vec2.sub(pose.position,home_offset)
	  var local_vec = math.vec2.sub(local_goal_vec,NedPos)
	  local_vec_len = math.vec2.length(local_vec)
	  local_vec = math.vec2.rotate(local_vec, -1*pose.orientation.yaw)
      #log("local vec len ", local_vec_len, " vec ", local_goal_vec.x, ", ",local_goal_vec.y, " angle to goal ", math.abs( math.vec2.angle(local_vec)))

		if(math.abs( math.vec2.angle(local_vec)) > 2.0 ){ # Goal is directly behind the robot, rotate.
			movebase_goto.x = -1.0
			movebase_goto.y = 0.0
		}
		else{
	 		# scale to desired vel
			#local_vec = math.vec2.scale(local_vec,1)
			# Limit speed
			#local_vec = math.vec2.newp(math.vec2.length(local_vec)*10,math.vec2.angle(local_vec))
			movebase_goto.x = local_vec.x
			movebase_goto.y = local_vec.y
		}
  }

	return movebase_goto	
}

function goto_point_naive(vec_to_target, last_wp){
	# var home_offset = math.vec2.new(pose.position.x_offset, pose.position.y_offset)
	# var NedPos = math.vec2.sub(pose.position,home_offset)
	var local_vec = math.vec2.sub(vec_to_target,pose.position)
	local_vec = math.vec2.rotate(local_vec, -pose.orientation.yaw)
	var last_wp_tol = 0.0
	if(last_wp){
		last_wp_tol = 0.2
	}
	if(math.vec2.length(local_vec) > GOTODIST_TOL+last_wp_tol){
		# Limit speed
		local_vec = math.vec2.newp(math.min(GOTO_MAXVEL,math.vec2.length(local_vec)),math.vec2.angle(local_vec))
		# Check if a waypoint is taking too long
		if(time_step - waypoint_set_time > STUCK_TIME_OUT){
			# if(BVMSTATE != BLIND_FOLLOW){
			# 	waypoint_set_time = time_step
			# }
			log("[WARN] Waypoint is taking very long to reach, stuck detected")
			if(BVMSTATE == "EXPLORE"){
				log("Explorer stuck while exploring !")
				CUR_PATH = nil
				local_planner_called = 0
				goto(0.0,0.0)
				return 1
			}
			else if(BVMSTATE == "HOME"){
				log("Explorer stuck while returning !")
				if(CUR_WP_IDX < size(CUR_PATH)-1){
					CUR_WP_IDX = CUR_WP_IDX + 1
					waypoint_set_time = time_step
					return 1
				}
				else if(CUR_WP_IDX >= size(CUR_PATH)-1){
					# Home reached, TODO: trigger hierarchial behaviror.
					log("[WARN] Premature declaration of HOME REACHED")
					BVMSTATE = "TURNEDOFF"
					goto(0.0,0.0)
					return 1
				}
			}
			else if(BVMSTATE == "WAYPOINT_GOTO"){
				log("[",id,"]ERROR: STUCK at the WP, can't reach WP (try a new one).")
				CUR_WP_FROM_VIZ ={}
				waypoint_set_time = 0
				BVMSTATE = "TURNEDOFF"
				goto(0.0,0.0)
				return 1
			}
		}
		# local_vec = math.vec2.scale(local_vec, 100)

		log("goto ",local_vec.x,",",local_vec.y, "Pos (",pose.position.x,",",pose.position.y,") target (",vec_to_target.x,",",vec_to_target.y,")")
		goto(local_vec.x, local_vec.y)
		
		return 1
	}
	else{
		goto(0.0,0.0)
		
		return 0
	}
}

function high_priority_robot_in_field(){
	var found_robot ={.0=0}
	neighbors.foreach(
	  	function(rid, data) {
			if(EXPLORER_IDs[rid]){
	  			# log("Explorer in range ",rid, "at distance ", data.distance)
	  			if(EXPLORER_IDs[rid] < EXPLORER_IDs[id] and data.distance < EXPLORATION_YEILD){
	    			found_robot[0] = 1
	  			}
	  		}
		}
	)
	return found_robot[0]
}

function reverse_table(table_c){
	var ret_table ={}
	var idx = size(table_c) - 1
	var f_idx = 0
	while(idx >= 0){
		# log("vec x ", table_c[idx].x, " y ", table_c[idx].y)
		hierarchial_path_to_source[f_idx] = math.vec2.new(table_c[idx].x, table_c[idx].y)
		# accumulate the path distance
		if(f_idx != 0){
			var diff_vec = math.vec2.sub(hierarchial_path_to_source[f_idx-1], hierarchial_path_to_source[f_idx])
			# path_distance_to_target = path_distance_to_target + math.vec2.length(diff_vec)
		}
		idx = idx - 1
		f_idx = f_idx + 1 
	}
	# log("size ", size(hierarchial_path_to_source))
}


function avoid_obs_using_potential(m_goto_target){
	if(ROLE == SHEEP){
		return avoid_obs_using_potential_footbot(m_goto_target)
	}
	else if(ROLE == DOG){
		return avoid_obs_using_potential_kh4(m_goto_target)
	}
}

function avoid_obs_using_potential_footbot(m_goto_target){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  var reaction_threshold = 42
  var desired_safety_distance = 10
  var obs_present =0

  var i = 0 
  while(i < size(proximity)){
	var l_prox = proximity[i].value * 100
	
	if(l_prox > 40){
		l_prox = 0
	} 
	else{
		obs_present = 1
	} 
	var potential = harmonMagnitude(l_prox, desired_safety_distance, HARMON_A0, HARMON_K)

	var pot_vec = math.vec2.newp(potential, proximity[i].angle)
	if(potential < 0 ){
		Accum.x = Accum.x + pot_vec.x
		Accum.y = Accum.y + pot_vec.y
		Accum.cnt = Accum.cnt + 1
	}
	i = i + 1
  }

  if(Accum.cnt > 0){
    Accum.x = Accum.x/Accum.cnt
    Accum.y = Accum.y/Accum.cnt
  }
  else{
	  obstacle_timer = 0
  }

  var normalized_target_vec = math.vec2.new(m_goto_target.x,m_goto_target.y)
  var vec_mag = math.vec2.length(normalized_target_vec)
  normalized_target_vec = math.vec2.scale(normalized_target_vec, 1/math.vec2.length(normalized_target_vec))
  var target_weight = 0.6
  var return_vec =  math.vec2.new((target_weight*normalized_target_vec.x)+ ((1-target_weight)*Accum.x),(target_weight*normalized_target_vec.y)+((1-target_weight)*Accum.y))
  return_vec = math.vec2.newp(vec_mag, math.vec2.angle(return_vec))
  if(obs_present == 1){
	  return_vec = math.vec2.scale(return_vec,70)
  }
  return return_vec
}

function avoid_obs_using_potential_kh4(m_goto_target){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  var reaction_threshold = 42
  var desired_safety_distance = 20
  var i = 0 
  while(i < size(proximity)){
	var potential = harmonMagnitude( (1.01 - proximity[i].value) *19, desired_safety_distance, HARMON_A0, HARMON_K)
	var pot_vec = math.vec2.newp(potential, proximity[i].angle)
	if(proximity[i].value > 0){
		Accum.x = Accum.x + pot_vec.x
		Accum.y = Accum.y + pot_vec.y
		Accum.cnt = Accum.cnt + 1
	}
	i = i + 1
  }

  if(Accum.cnt > 0){
    Accum.x = Accum.x/Accum.cnt
    Accum.y = Accum.y/Accum.cnt
  }
  var normalized_target_vec = math.vec2.new(m_goto_target.x,m_goto_target.y)
  var vec_mag = math.vec2.length(normalized_target_vec)
  normalized_target_vec = math.vec2.scale(normalized_target_vec, 1/math.vec2.length(normalized_target_vec))
  var target_weight = 0.2
  var return_vec = math.vec2.new((target_weight*normalized_target_vec.x)+ (Accum.x),(target_weight*normalized_target_vec.y)+(Accum.y))
  return_vec = math.vec2.newp(vec_mag, math.vec2.angle(return_vec))
  # return_vec = math.vec2.scale(return_vec,10)
  return return_vec
}

function ultrasound_obs_potential(){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  var reaction_threshold = 42
  var desired_safety_distance = 45
  var i = 0 
  while(i < size(ultrasound)){
	var potential = harmonMagnitude( (ultrasound[i].value*200)+25, desired_safety_distance, HARMON_A0, HARMON_K)
	if(ultrasound[i].value == 0) potential = 0
	var pot_vec = math.vec2.newp(potential, ultrasound[i].angle)
	log("us ", i ," -> ", ultrasound[i].value, " pot ", potential, " dis ", (ultrasound[i].value*200)+25)
	if((ultrasound[i].value*200)+25 < reaction_threshold and potential < 0){
		Accum.x = Accum.x + pot_vec.x
		Accum.y = Accum.y + pot_vec.y
		Accum.cnt = Accum.cnt + 1
	}
	i = i + 1
  }
}


function avoid_nei_using_potential(m_target){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  neighbors.foreach(
    function(rid, data){
      var potential = harmonMagnitude(data.distance, SAFETY_DISTANCE+10, HARMON_A0, HARMON_K)
      if(data.distance < SAFETY_DISTANCE+50 and potential < 0){
        var my_vec = math.vec2.newp(data.distance, data.azimuth)
        # debug.rays.add(0,100,0, my_vec.x/100, my_vec.y/100, 0.0)
        var pot_vec = math.vec2.newp(potential, data.azimuth)
        Accum.x = Accum.x + pot_vec.x
        Accum.y = Accum.y + pot_vec.y
        Accum.cnt= Accum.cnt +1
      }
    }
  )
  if(Accum.cnt > 0){
    Accum.x = Accum.x/Accum.cnt
    Accum.y = Accum.y/Accum.cnt
  }
  var normalized_target_vec = math.vec2.new(m_target.x,m_target.y)
  var vec_mag = math.vec2.length(normalized_target_vec)
  normalized_target_vec = math.vec2.scale(normalized_target_vec, 1/math.vec2.length(normalized_target_vec))
  
  # if(math.vec2.length(Accum) > 0) Accum = math.vec2.scale(Accum, 1/math.vec2.length(Accum))
  var target_weight = 3.5
  var return_vec = math.vec2.new((target_weight*normalized_target_vec.x)+ (Accum.x),(target_weight*normalized_target_vec.y)+(Accum.y))
  return_vec = math.vec2.newp(vec_mag, math.vec2.angle(return_vec))
#   return_vec = math.vec2.scale(return_vec,500)

  return return_vec
}


function avoid_nei_using_potential_normal_prox(m_target){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  neighbors.foreach(
    function(rid, data){
      var potential = harmonMagnitude(data.distance, SAFETY_DISTANCE+10, HARMON_A0, HARMON_K)
      if(data.distance < SAFETY_DISTANCE+50 and potential < 0){
        var my_vec = math.vec2.newp(data.distance, data.azimuth)
        # debug.rays.add(0,100,0, my_vec.x/100, my_vec.y/100, 0.0)
        var pot_vec = math.vec2.newp(potential, data.azimuth)
        Accum.x = Accum.x + pot_vec.x
        Accum.y = Accum.y + pot_vec.y
        Accum.cnt= Accum.cnt +1
      }
    }
  )
  if(Accum.cnt > 0){
    Accum.x = Accum.x/Accum.cnt
    Accum.y = Accum.y/Accum.cnt
  }
  var normalized_target_vec = math.vec2.new(m_target.x,m_target.y)
  var vec_mag = math.vec2.length(normalized_target_vec)
  normalized_target_vec = math.vec2.scale(normalized_target_vec, 1/math.vec2.length(normalized_target_vec))
  
  # if(math.vec2.length(Accum) > 0) Accum = math.vec2.scale(Accum, 1/math.vec2.length(Accum))
  var target_weight = 3.5
  var return_vec = math.vec2.new((target_weight*normalized_target_vec.x)+ (Accum.x),(target_weight*normalized_target_vec.y)+(Accum.y))
  return_vec = math.vec2.newp(vec_mag, math.vec2.angle(return_vec))
  # return_vec = math.vec2.scale(return_vec,500)

  return return_vec
}

function harmonMagnitude(dist, desiredDist, a0, k) {
  return a0 + ((dist - desiredDist)/math.abs(dist - desiredDist)) * 1.0/2.0 * k * (dist - desiredDist)^2
}

function copy_table_vec2(t){
	var t2 = {}
	foreach(t, function(key, value) {
		t2[key] = math.vec2.new(value.x, value.y)
		})
	return t2
}

function compute_exploration_quota_used(){
	var c_dist_vec = math.vec2.sub(pose.position, old_pose)
	used_exploration_quota = used_exploration_quota + math.vec2.length(c_dist_vec)
}
